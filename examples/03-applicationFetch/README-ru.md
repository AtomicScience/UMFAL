# Подгрузка приложений
[This material is available in **English**](https://github.com/AtomicScience/UMFAL/tree/master/examples/03-applicationFetch)

Этот пример объясняет, как пользоваться возможностями UMFAL не только в точке входа, но и в других модулях, с помощью механизма **подгрузки приложений**.

Также пример демонстрирует, что модулями могут быть не только таблицы

*Новые темы в данном примере*
1. Подгрузка объекта приложения
2. Нетабличные модули

## Разбор кода
### init.lua
`init.lua` - простая точка входа.

Она вызывает функцию у одного модуля, и на этом все
### hello.lua
В этом модуле мы хотим использовать другой модуль.

Но появляется проблема - как нам заполучить **объект приложения**? В предыдущих примерах, мы получали его при инициализации:
```lua
local app = require("umfal").initAppFromRelative("applicationFetch")
```
Но мы не можем инициализировать приложение в каждом модуле, вместо этого мы должны **подргузить** уже инициализированное в точке входа приложение из кеша UMFAL

В `hello.lua` это делается следующим образом:
```lua
local app = require("umfal")("applicationFetch")
```
`"applicationFetch"` это идентификатор приложения - такой же, какой мы использовали при инициализации

Также, эта конструкция позволяет использовать **ленивые модули**, которые будут объяснены позже

После **подгрузки**, полученный объект приложения используется как обычно:
```lua
print("Hello, " .. app.world() .. "!")
```
### world.lua
Этот модуль необычен тем, что вместо возврата таблицы функций, он возвращает просто функцию

Это сделано для демонстрации того, чтобы продемонстрировать - модулем может быть не только таблица, но и вообще любое значение 

Но модули не должны возвращать `nil` *(единственное исключение - использование ленивых модулей, которые будут объяснены позднее)*