# Ленивые модули
[This material is available in **English**](https://github.com/AtomicScience/UMFAL/tree/master/examples/06-lazyModules)

Этот пример демонстрирует, пожалуй, самую крутую возможность UMFAL - **ленивые модули**

*Новые темы в данном примере:*
1. Синтаксис ленивых модулей
2. Приоритет между содержимым ленивого модуля и возвращаемым значением

## Что такое ленивый модуль?
Вы наверняка помните структуру обычного модуля:
```lua
local module = {}
...
return module
```
Эти две строчки повторяются в каждом файле, и это не может не раздражать

Поэтому UMFAL предлагает другое решение - **ленивые модули**!

Вот простейший пример:
```lua
local app, lazyModule = require("umfal")("lazyModules") 

function lazyModule.sayHello()
    print("Hello")
end
```
Оказывается, при подгрузке приложения, UMFAL возвращает не только объект приложения, но и специальную **ленивую таблицу**, которую можно заполнить любыми значениями. И после заполнения её не нужно явно возвращать!

## Разбор кода
### init.lua
Просто вызываем функции из двух модулей, ничего необычного
### hello.lua
Это **ленивый** модуль - он использует **ленивую таблицу** вместо того, чтобы создавать и возвращать модуль вручную
### world.lua
Этот модуль - ответ на вопрос *"Но ведь раньше мы создавали и возвращали модули как обычно! Как UMFAL выбирает между содержимым ленивой таблицы и тем, что модуль возвращает?"*

Ответ на этот вопрос прост - если модуль что-то возвращает, UMFAL **всегда** игнорирует содержимое ленивой таблицы и сохраняет возвращаемое значение